`2018年8月22日19:34:48`

## 工厂方法模式

#### 定义

>吾欲娶卿，必问卿之父母，谓之父母之命。

工厂方法模式（Factory Method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 ——《设计模式：可复用面向对象软件的基础》

#### 使用场景

工厂方法模式在简单工厂模式的基础上，将判断逻辑的选择权上交给客户端，让客户端决定使用哪个具体工厂类。这算是工厂方法相比与简单工厂模式的缺点吧，这样的话，你就要事先知道有什么具体工厂类。相对于直白的new对象，不需要记住具体产品类，服务端隐藏了具体产品类的创建细节，在具体工厂类中不一定就是创建具体产品类，也可以做一些其他事情，符合面向对象的封装性。

简单工厂模式加产品，需要修改内部判断逻辑，这是违反设计模式六大模式中的开闭原则（挖坑），就是对扩展是开放的，对修改是关闭的。工厂方法模式加产品，只需增加相对应的具体工厂对象即可，符合开闭原则，这是工厂方法模式优点之一。个人观点：工厂方法模式适合那种经常更替（即增加和删除）具体产品对象的场景，正好利用了这个优点。如服装换季，你是一个设计师，换季了新的产品上架，加上新产品，老板选择新工厂，销售商家只需要从工厂获取新产品即可，旧产品下架，和旧工厂合同到期，就这样。

#### 角色

将简单工厂模式的<b>工厂角色</b>内部逻辑判断上交给客户端后，分别封装创建对象细节到具体工厂类，具体工厂类都继承于一个共同的接口。简单工厂模式可查看：[简单工厂模式](https://www.cnblogs.com/mingmingcome/p/9513238.html)。

工厂方法模式有以下四种角色：

- 抽象工厂角色（IFactory）：具体工厂公共接口，定义工厂方法返回产品
- 具体工厂角色（ConcreteFactoryImpl)：继承工厂工厂公共接口，实现工厂方法，运行期返回具体产品
- 抽象产品角色（IProduct）
- 具体产品角色（ConcreteProductImpl）

#### 图示

![工厂方法模式结构图](https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/factory-factory-method-structure.jpg)

#### 代码示例

类依赖关系图：
![]()


