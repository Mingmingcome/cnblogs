`2019年5月23日21:50:31`

## 组合模式（composite pattern）

#### 定义

>组合模式，将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。————《设计模式：可复用面向对象软件的基础》

组合模式是一个结构型模式。

#### 使用场景

当你发现需求中是用树形结构体现部分与整体层次关系的结构时，且你希望用户可以忽略整体和部分、组合对象和单个对象的不同，统一地使用组合结构中的所有对象时，就应该使用组合模式。

组合模式解决上面所说的两个问题：

1、部分与整体的层次关系表示为树形结构、

2、部分与整体的对象，是能让客户端能统一对待、不需区分的对象。

场景：树形菜单，文件、文件夹的管理。

#### 角色

<i>抽象组件角色（Component）：</i>

- 所有组件的抽象
- 声明在组合模式中的对象的接口

<i>叶子角色（Leaf）：</i>

- 表示组合模式中的叶子对象
- 实现了Component
- 没有子节点

<i>组合角色（Composite）：</i>

- 表示一个组合组件（拥有叶子节点）
- 实现了Component，
- 拥有子节点，并具备操作Component的方法，增加组件、删除组件等

#### 图示

组合模式结构图：

![组合模式结构图](https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/composite-pattern-structure.jpg)

#### 代码示例

深圳某公司总部使用的OA系统，由于简单易用，反响良好的原因，准备被推广到各分公司使用。

关于组织结构的设计，原来是这样的：一个公司总部下面有人力资源部、财务部等。组织结构图如下：

![应用组合模式前的组织结构图](https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/composite-pattern-before-structure.jpg)

类图如下：

![应用组合模式前的组合结构类图](https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/composite-pattern-before-class-diagram.JPG)

代码如下：

``` java
// 组织
public interface Organization {
    void addOrg(Department department);
    void removeOrg(Department department);
    String getName();
    void showOrg();
    void displayDuty();
}
// 公司总部
public class Headquarters implements  Organization {
    private List<Department> departments = new ArrayList<>();

    @Override
    public void addOrg(Department department) {
        departments.add(department);
    }

    @Override
    public void removeOrg(Department department) {
        departments.remove(department);
    }

    public String getName() {
        return this.getClass().getSimpleName();
    }

    @Override
    public void showOrg() {
        System.out.println("-" + getName());
        for (Department department : departments) {
            System.out.println("--" +  department.getName());
        }
    }

    @Override
    public void displayDuty() {
        for(Department department : departments) {
            department.duty();
        }
    }
}
// 部门
public interface Department {
    String getName();
    void duty();
}
// 财务部
public class FinanceDepartment implements Department {

    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }

    @Override
    public void duty() {
        System.out.println("财务部负责公司财务收支管理");
    }
}
// 人力资源部
public class HumanResourceDepartment implements Department{

    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }

    @Override
    public void duty() {
        System.out.println("人力资源部负责员工招聘培训管理");
    }
}
// 测试类
public class Before {
    public static void main(String[] args) {
        Organization hq = new Headquarters();

        Department fnc = new FinanceDepartment();

        Department hr = new HumanResourceDepartment();

        hq.addOrg(fnc);
        hq.addOrg(hr);

        System.out.println("====组织结构====");
        hq.showOrg();
        System.out.println("====部门职责====");
        hq.displayDuty();
    }
}
```

测试结果：

![应用组合模式之前的测试结果](https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/composite-pattern-before-result.JPG)

组织结构需求现在变成了：<b>总部下面不仅是只有部门，还会有分公司。</b>之前的设计明显是不可以用了，接口Organization中addOrg、removeOrg方法都是面对于Department的。现在需要<b>不区分部门、分公司和总部，且组织结构是用树形结构来体现层次关系的</b>。组合模式就派上用场了。

应用组合模式之后的类图为：

#### 透明方式与安全方式



#### 优点

对服务端来说，以树形结构清晰定义了整体和部分的层次关系，只需要知道自己的父节点就可以自由添加子节点。

对客户端来说，可以忽略整体和部分的差异，不需关心是单个对象还是组合对象，简化了逻辑。

#### 总结


#### 完     


