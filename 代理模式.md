`2018年8月8日16:01:54`

## 代理模式

#### 使用场景

>代理模式，为其他对象提供一种代理以控制对这个对象的访问。 ------《设计模式：可复用面向对象软件的基础》

1、远程代理：对一个位于不同地址空间的对象提供一个本地代表，隐藏这个对象存在于不同地址空间的事实，例如RMI的stub（RMI也是比较重要的概念）。这个不同的地址空间可以是在同一主机中，也可以是在不同主机中。

2、虚拟代理：如果创建一个开销比较大的对象，可以先创建开销小的代理对象，真实对象只在需要时才被真正创建，延迟加载。

3、安全代理（保护代理）：用来控制真实对象访问时的权限。

4、智能引用代理：当调用真实对象时，代理提供一下额外的操作，例如把对象被调用的次数记录下来（即引用计数）

5、缓冲代理：为某一目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。

#### 角色

抽象角色（Subject）：声明真实对象和代理对象的共用接口，这样使得在任何使用真实对象（RealSubject）的地方都可以使用代理对象（Proxy）。

代理角色（Proxy）：代理对象角色内部包含对真实对象的引用，从而可以操作真实对象，同时代理对象提供域真实对象相同的接口以便任何时刻都能代替真实对象。代理对象可以实现上面使用场景所述的功能。

真实角色（RealSubject）：代理模式所代表的真实对象。

#### 静态代理
#### -- 图示

![静态代理](http://p2cc2nh3y.bkt.clouddn.com/proxy-pattern/static-proxy.jpg)

#### -- 代码示例

抽象接口（Subject.java）：
``` java
package com.mingmingcome.designpattern.proxy.staticproxy;

/** 
 * @ClassName: Subject
 * @Description: 抽象接口：代理对象和真实对象的共用接口
 * @author: luhaoming
 * @date: 2018年8月12日 下午2:56:43
 */
public interface Subject {
	void request();
}
```

代理类（Proxy.java）：
``` java
package com.mingmingcome.designpattern.proxy.staticproxy;

/** 
 * @ClassName: Proxy
 * @Description: 代理对象：代理对象角色内部包含对真实对象的引用，从而可以操作真实对象，
 * 同时代理对象提供域真实对象相同的接口以便任何时刻都能代替真实对象。
 * @author: luhaoming
 * @date: 2018年8月12日 下午3:00:10
 */
public class Proxy implements Subject {
	// 真实主题对象的引用
	private Subject subject;
	
	public Proxy(Subject subject) {
		this.subject = subject;
	}
	
	@Override
	public void request() {
		preRequest();
		// 执行真实对象的方法
		subject.request();
		afterRequest();
	}
	
	private void preRequest() {
		System.out.println("这是在调用真实对象之前做的事情。。。");
	}
	
	private void afterRequest() {
		System.out.println("这是在调用真实对象之后做的事情。。。");
	}

}
```

真实主题类（RealSubject）：
``` java
package com.mingmingcome.designpattern.proxy.staticproxy;

/** 
 * @ClassName: RealSubject
 * @Description: 真实对象
 * @author: luhaoming
 * @date: 2018年8月12日 下午3:10:59
 */
public class RealSubject implements Subject {
	
	@Override
	public void request() {
		System.out.println("真实的请求");
	}

}
```

测试类（TestStaticProxy.java）：
``` java
package com.mingmingcome.designpattern.proxy.staticproxy;

/** 
 * @ClassName: TestStaticProxy
 * @Description: 静态代理测试类
 * @author: luhaoming
 * @date: 2018年8月12日 下午3:22:19
 */
public class TestStaticProxy {

	public static void main(String[] args) {
		Subject subject = new RealSubject();
		Proxy proxy = new Proxy(subject);
		proxy.request();
	}

}
```

执行结果：
```
这是在调用真实对象之前做的事情。。。
真实的请求
这是在调用真实对象之后做的事情。。。
```

总结：

1、可以做到在不修改真实对象的功能下，对目标功能扩展

2、缺点：因为代理对象要与真实对象实现同一个接口，这样就会有很多与真实对象类相对应的代理类。另外，如果接口增删方法，都要同时维护真实对象类和代理对象类。

3、在编译期就决定了代理类的功能，决定为哪个真实对象代理，以后不可修改

#### 讨论

上面我们用静态代理的方式实现了代理功能，那为什么还需要动态代理呢？讨论一下两种情况：

>1、在抽象接口中增加100个方法，需要为每个方法都添加日志

>2、有100个不同抽象接口的实现类，需要为每个类中的其中一个方法添加日志

第一种情况，使用静态代理的代理类：
``` java
public class Proxy implements Subject {
	// 真实主题对象的引用
	private Subject subject;
	
	public Proxy(Subject subject) {
		this.subject = subject;
	}
	
	@Override
	public void request0() {
		System.our.println("调用Subject的request0方法");
		subject.request0();
	}

	@Override
	public void request1() {
		System.our.println("调用Subject的request1方法");
		subject.request1();
	}

	// 为每个接口的方法提供日志

}
```

第二种情况，要为每个实现类创建一个相对应的代理类，多了100个类。

<b>静态代理适合：被代理的对象固定，我们只需要去代理一个类或者若干固定的类，数量不是太多的时候。</b>但是像上面讨论的两种情况，我们可以使用动态代理优雅解决要写很多方法或创建很多类的问题。

#### 动态代理

#### 图示

下面是JDK的动态代理：
![动态代理](http://p2cc2nh3y.bkt.clouddn.com/dynamic-proxy.jpg)

#### 代理示例

首先，来了解一下java.lang.reflect包下的InvocationHandler接口和Proxy类的newInstance方法。

InvocationHandler里面只有一个方法，就是invoke。
``` java
package java.lang.reflect;

public interface InvocationHandler {
	/**
	 * Processes a method invocation on a proxy instance and returns
     * the result.  This method will be invoked on an invocation handler
     * when a method is invoked on a proxy instance that it is
     * associated with.
     * 处理代理实例的方法调用，返回结果。当一个方法在其相关联的代理实例上调用，
     * 这个方法会在调用处理器上被调用。
     * （代理实例的方法——>InvocationHandler的方法——>真正对象的方法）
     */
    public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable;
}
```

Proxy类中的newInstance方法：
``` java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) 
	throws IllegalArgumentException
```
Proxy类中都是static方法，可以知道这个应该是一个工具类，newInstance方法用来动态生成代理类。

三个参数：
<ul>
	<li>`ClassLoader loader`：the class loader to define the proxy class定义代理类的类加载器</li>
	<li>`Class<?>[] interfaces`：the list of interfaces for the proxy class to implement代理类要实现的接口列表/li>
	<li>`InvocationHandler h`：the invocation handler to dispatch method invocations to分发方法调用的调用处理器</li>
</ul>


#### CGLIB代理
