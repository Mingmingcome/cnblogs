`2021年11月27日18:24:29`

## 迭代器模式

#### 定义

``` text
Provide a way to access the elements of an aggregate object sequentially without
exposing its underlying representation. ——《Design Patterns: Elements of Reusable Object-Oriented Software》
```

提供一种顺序访问集合的元素而不暴露其底层表示的方法。 ——《设计模式：可复用面向对象软件的基础》

迭代器模式是一种行为型模式。

#### 明明讲

迭代器模式就是提供一种遍历的方法，这种方法有两个特点：一是按你想要的方式访问到你想访问的元素，二是不暴露底层是什么存的，怎么存的。

在开发过程中，我们使用类库提供给我们的集合，遍历集合中的元素，使用的就是迭代器。一般情况下，单单作为使用者，我们是不会去关注这些集合底层结构是什么，只需要拿到我们需要的数据，进行业务逻辑的处理就可以了。但是呢，作为一个优秀的开发者，当然要深入了解各种集合的数据结构及操作的。当然啦，我们是不会说我们是为了面试才去了解的啦。（此处应该有表情）

常见用法：
``` java
    List<String> list = new ArrayList<>();
    list.add("ming");
    list.add("ming");
    list.add("come");
    for(String s : list) {
        System.out.println(s);
    }
```

上面代码中的for循环遍历列表中的数据，Java编译器会将这段代码变成使用ArrayList中的迭代器去遍历数据。编译之后再反编译，代码如下：

``` java
    List<String> list = new ArrayList();
    list.add("ming");
    list.add("ming");
    list.add("come");
    Iterator var1 = list.iterator();

    while(var1.hasNext()) {
        String s = (String)var1.next();
        System.out.println(s);
    }
```

#### 图示
 


#### 角色

<b>抽象迭代器角色(Iterator)：</b>

- 定义一个接口，用于访问和遍历元素，它的方法一般有：first、next、hasNext等。

<b>具体迭代器角色(ConcreteIterator)：</b>

- 实现【抽象迭代器角色】定义的执行操作
- 记录集合迭代时的当前位置，如图中的currentItem()方法
- 当客户端控制迭代，迭代器被称作外部迭代器；当迭代器控制迭代，迭代器是内部迭代器。(When the client controls the iteration, the iterator is called an external
 iterator, and when the iterator controls it, the iterator is aninternal iterator.)
- Java类库中AbstractList、ArrayList、HashMap中都有具体迭代器
  
<b>抽象集合角色(Aggregate)：</b>

- 定义了一个接口，用于创建迭代器对象

<b>具体集合角色(ConcreteAggregate)：</b>

- 实现【抽象集合角色】，实现创建迭代器对象方法，返回一个迭代器实例

#### 代码示例
#### 使用场景
#### 优点
#### 缺点
#### 总结
#### 参考