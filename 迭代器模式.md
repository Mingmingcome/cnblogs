`2021年11月27日18:24:29`

## 迭代器模式

#### 定义

``` text
Provide a way to access the elements of an aggregate object sequentially without
exposing its underlying representation. ——《Design Patterns: Elements of Reusable Object-Oriented Software》
```

提供一种顺序访问集合的元素而不暴露其底层表示的方法。 ——《设计模式：可复用面向对象软件的基础》

迭代器模式是一种行为型模式。

#### 明明讲

迭代器模式就是提供一种遍历的方法，这种方法有两个特点：一是按你想要的方式访问到你想访问的元素，二是不暴露底层是什么存的，怎么存的。

在开发过程中，我们使用类库提供给我们的集合，遍历集合中的元素，使用的就是迭代器。一般情况下，单单作为使用者，我们是不会去关注这些集合底层结构是什么，只需要拿到我们需要的数据，进行业务逻辑的处理就可以了。但是呢，作为一个优秀的开发者，当然要深入了解各种集合的数据结构及操作的。当然啦，我们是不会说我们是为了面试才去了解的啦。（此处应该有表情）

常见用法：
``` java
    List<String> list = new ArrayList<>();
    list.add("ming");
    list.add("ming");
    list.add("come");
    for(String s : list) {
        System.out.println(s);
    }
```

上面代码中的for循环遍历列表中的数据，Java编译器会将这段代码变成使用ArrayList中的迭代器去遍历数据。编译之后再反编译，代码如下：

``` java
    List<String> list = new ArrayList();
    list.add("ming");
    list.add("ming");
    list.add("come");
    Iterator var1 = list.iterator();

    while(var1.hasNext()) {
        String s = (String)var1.next();
        System.out.println(s);
    }
```

#### 图示

迭代器模式结构图：

![迭代器模式结构图]()

#### 角色

<b>抽象迭代器角色(Iterator)：</b>

- 定义一个接口，用于访问和遍历元素，它的方法一般有：first、next、hasNext等。

<b>具体迭代器角色(ConcreteIterator)：</b>

- 实现【抽象迭代器角色】定义的执行操作
- 记录集合迭代时的当前位置，如图中的currentItem()方法
- 当客户端控制迭代，迭代器被称作外部迭代器；当迭代器控制迭代，迭代器是内部迭代器。(When the client controls the iteration, the iterator is called an external
 iterator, and when the iterator controls it, the iterator is aninternal iterator.)
- Java类库中AbstractList、ArrayList、HashMap中都有具体迭代器
  
<b>抽象集合角色(Aggregate)：</b>

- 定义了一个接口，用于创建迭代器对象

<b>具体集合角色(ConcreteAggregate)：</b>

- 实现【抽象集合角色】，实现创建迭代器对象方法，返回一个迭代器实例

#### 代码示例

类图：

![代码示例类图]()

##### 抽象迭代器角色：

```java

```

##### 抽象集合角色：

```java

```

##### 具体集合角色和具体迭代器角色：

```java
// 具体集合类
public class FamilyAggregateImpl implements FamilyAggregate {

    private int generation;

    private List<String>[] generations;

    public FamilyAggregateImpl(int generation) {
        this.generation = generation;
        this.generations = initFamily(generation);
    }

    private List<String>[] initFamily(int generation) {
        List<String>[] name = new ArrayList[generation];
        for (int i = 0; i < generation; i++) {
            name[i] = new ArrayList<>();
        }
        return name;
    }

    public boolean addFamily(int generation, String name) {
        return generations[generation - 1].add(name);
    }

    @Override
    public NameIterator createIterator() {
        return new NameIteratorImpl();
    }

    // 具体迭代器
    private class NameIteratorImpl implements NameIterator {

        int currentGeneration;

        int cursor;

        NameIteratorImpl() {
            this.currentGeneration = FamilyAggregateImpl.this.generation;
        }

        @Override
        public String next() {
            int i = cursor;
            List<String>[] generations = FamilyAggregateImpl.this.generations;
            if (currentGeneration == 1 && cursor == generations.length) {
                System.out.println("无剩余可遍历");
            }
            String name = generations[currentGeneration - 1].get(i);
            cursor = i + 1;
            if (cursor == generations[currentGeneration - 1].size()) {
                currentGeneration--;
                cursor = 0;
            }
            return name;
        }

        @Override
        public boolean hastNext() {
            return currentGeneration != 0;
        }
    }

}
```

##### 客户端

```java
public class Client {
    public static void main(String[] args) {
        FamilyAggregate family = new FamilyAggregateImpl(3);

        family.addFamily(1, "晓月");
        family.addFamily(2, "爸爸");
        family.addFamily(2, "妈妈");
        family.addFamily(2, "叔叔");
        family.addFamily(2, "婶婶");
        family.addFamily(3, "爷爷");
        family.addFamily(3, "奶奶 ");

        NameIterator iterator = family.createIterator();
        while (iterator.hastNext()) {
            String name = iterator.next();
            System.out.println(name);
        }

    }
}
```

#### 使用场景
#### 优点
#### 缺点
#### 总结
#### 参考